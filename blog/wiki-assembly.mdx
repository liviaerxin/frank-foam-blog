---
foam_template:
  name: Blog Docusaurus Template
  description: Creates Docusaurus blog/slip
  filepath: blog/wiki-assembly.mdx # See using [Variable transforms](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_variable-transforms )
authors:
  - frank
tags:
  - Wiki Assembly
description: Wiki Assembly
keywords:
  - Wiki Assembly
image: https://i.imgur.com/mErPwqL.png
date: 2023-11-22
draft: false
enableComments: true # for Gisqus
---

# Wiki Assembly

Why `Assembly` language is important to to learn?

1. The most low-level language that is closely tied to the hardware such as `CPU`.
   - `Assembly` code implements a symbolic (human-readable) representation of the binary machine code.
   - `Assembly` language is written to follow the `CPU` execution logic directly.
2. `Assembly` language facilities a deeper understanding how `CPU` actually do its job.

Why `Assembly` language is critical elementary foundation to other higher-level language, E.g. `C`?

`Assembly` code is the important medium for compiling `C` code to machine code.
When `C` program being compiled to an binary object file, the `GCC` compiler will do following:

1. `C` code will be compiled into `Assembly` code
2. `Assembly` code will be translated into machine code

Is `Assembly` language cross-platform?

No, `Assembly` language is specific in the specific platform. E.g. `X86` CPU-architecture has its own `Assembly` instruction sets as well as the `arm` CPU.

`Assembly` is CPU-dependent as machine code is CPU-dependent, while `C` language is CPU-independent for cross-platform.

Is the first version of `GCC` written in `Assembly`?

No, `C` started with the `BCPL` language, [](https://stackoverflow.com/questions/18125490/how-was-the-first-c-compiler-written)
<!--truncate-->

## Assembler

- GNU assembler (GAS) 
  - x86-64 GNU assembler 
    * AT&T syntax
  - aarch64 GNU assembler
    * aarch64/arm64 syntax
- Clang Assembler
  - external Assembler
    - GNU Assembler
  - LLVMâ€™s integrated assembler
  - [](https://clang.llvm.org/docs/Toolchain.html#assembler)  
- Netwide assembler (NASM)
  * Intel syntax
  * x86-64
    * macOS
    * linux
    * windows
- MASM
  * Intel syntax

### XXX

```asm title="print.asm"
; print.asm
; nasm -f elf64 print.asm && ld print.o && ./a.out ; echo $?
; objdump -d a.out
section .data
message db, "Welcome,   to, Segmentation, Faults!, "

section .text

global _start

_printMessage:
    mov rax, 4       ; System call number for sys_write
    mov rbx, 1       ; File descriptor 1 is stdout
    mov rcx, message ; Pointer to the message string
    mov rdx, 32      ; Length of the message
    int 0x80         ; Call kernel

    ret ; Return from the function

_exit:
    mov rax, 1 ; System call number for sys_exit
    mov rbx, 0 ; Exit code 0
    int 0x80   ; Call kernel

_start:
    call _printMessage ; Call the print message function
    mov  rax, 1        ; System call number for sys_exit
    mov  rbx, 1        ; Exit code 0
    int  0x80          ; Call kernel
```

```asm title="sum.asm"
; sum.asm
; nasm -f elf64 sum.asm && ld sum.o && ./a.out ; echo $?
; objdump -d a.out
section .text
global _start

; Function to calculate the sum of two integers
sum:
    mov rax, rdi   ; Move the first argument (a) to rax
    add rax, rsi   ; Add the second argument (b) to rax
    ret            ; Return with the result in rax

_start:
    ; Example usage of the sum function
    mov rdi, 5     ; First argument: a = 5
    mov rsi, 7     ; Second argument: b = 7

    call sum       ; Call the sum function

    ; The result is now in rax
    ; It can be used or printed, depending on the context
    mov rdi, rax   ; Exit code 0

    ; Exit the program
    mov rax, 60    ; System call number for sys_exit
    syscall        ; Make the system call
```

## Memory Layout

The structure of an assembly file generally consists of serval section:

- `.text` section:
   - `.text` section is generally read-only. It is typically used for storing executable code, and it is not intended to be modified during program execution.
   - `.text` section contains the machine code instructions that the processor will execute.
   - `.text` section contains global constant data.
- `.data` section:
   - `.data` section is writable. It is used for storing initialized data that can be modified during the execution of the program.
   - `.data` section contains global variable data.
- `.bss` section: 
  - It's mostly the same with `.data` section except it's used for storing uninitialized data 
- `.rodata` section:
  - It is used for read-only data, such as constant strings.

Here's a simple example illustrating the use of these sections:


```asm
.section .text
.global _start

_start:
    // Code goes here

.section .data
my_data:
    .word 42   // Initialized data

.section .bss
my_uninitialized_data:
    .skip 4    // Uninitialized data, occupies 4 bytes

.section .rodata
my_string:
    .asciz "Hello, World!"  // Read-only data
```

A compiled program's memory layout consists of these segments.
A running program's memory layout consists of these segments, and also `heap` and `stack` memory.

## Memory Layout of a Running Program

A running program typically consists of serval segments or sections, each serving a specific purpose but common sections include:

- `Stack`:
  - Stores local variables and function call information.
  - Memory is automatically allocated and de-allocated as functions are called and return.
  - Register(`sp` in `arm64`, stack pointer) is used to manage and point to the stack memory.
  - Size is limited(may lead to **stack overflow**).
    - set via `ulimit -s` in linux.
- `Heap`:
  - Dynamic memory managed by programmer at runtime.
  - Memory is allocated and deallocated explicitly using functions like `malloc`/`free` in `C`, and `new`/`delete` in `C++`, `brk` system call in `assembly` etc.
  - Store dynamic data that can be shared across functions. Data lifecycle is not bound to functions.
  - Size is much larger than the stack,
- `Data`(`.data`, `.bss`):
  - Stores global variables/constants, separated into initialized and uninitialized
- `Text`(`.text`): 
  - Stores the code being executed

[CS 225 | Stack and Heap Memory](https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/)

## Label

## Instruction

Assembly instructions are human readable representation of the machine code as CPU can only understand the machine code.

Instruction: Opcode + Oprand 


### Opcode

[Intel x86 Assembler Instruction Set Opcode Table](http://sparksandflames.com/files/x86InstructionChart.html)

### Oprand

Data area

#### Register Operand

```asm
mov   rdi, rsi
```

#### Immediate Operand

```asm
mov   rdi, 0x21
mov   rdi, 5
mov   edi, 0x21314151
```

in `aarch64`, the immediate value is subject to:
- Arithmetic instructions (add{s}, sub{s}, cmp, cmn) take a 12-bit unsigned immediate with an optional 12-bit left shift.
- Move instructions (movz, movn, movk) take a 16-bit immediate optionally shifted to any 16-bit-aligned position within the register.
- Address calculations (adr, adrp) take a 21-bit signed immediate, although there's no actual syntax to specify it directly - to do so you'd have to resort to assembler expression trickery to generate an appropriate "label".
- Logical instructions (and{s}, orr, eor, tst) take a "bitmask immediate".

#### Memory Operand

```asm
mov   rdi, [sdi]
```

### Instruction Encoding

Assembler will encode the human-readable instruction into machine code.

- In `aarch64`, the encoding instruction is **fixed-size**(4 bytes) machine code.
- In `x86_64`, the encoding instruction is **non-fixed-size**(up to 16 bytes) machine code.

[Encoding Real x86 Instructions](http://www.c-jump.com/CIS77/CPU/x86/lecture.html)

Let's have a glimpse on the impact of the **fixed/non-fixed** encoding.

In order to load 32-bit integer, `x86_64` need only **one** instruction while more instructions are needed for `aarch64` to do that.

Load a 32-bit integer `0x1a2b3c4d` in `x86_64`,

```asm
mov     rid, 0x1a2b3c4d
```

Load a 32-bit integer 32-bit `0x1a2b3c4d` in `aarch64`(the immediate value in `mov` must be in the range of `16-bit`, so it needs **two** instructions),

```asm
movz    x1, 0x3c4d
movk    x1, 0x1a2b, lsl 16
```

## NASM x86_64 cheat sheet

## GAS aarch64 cheat sheet

## Bootstrap a compiler for new language

New programming language and its corresponding compiler is mainly developed from an existing language. The progress is called **bootstrapping**, which can be summarized as,

```sh
C1  + L1  -> C20
C20 + L2u -> C21
C21 + L2  -> C22
C22 + L2  -> C23
C23 + L2  -> C24
```

`L1` : an existing language 
`C1` : an existing compiler for language `L1`
`C20`: a compiler written in language `L1` for language `L2u`
`C21`: a compiler written in language `L2u` for language `L2`
`L2u`: is subset of language `L2`

Bootstrapping stage:

1. Write a bootstrap compiler `C20` to understand language `L2u`(a subset of language `L2`) in using existed language `L1` and its corresponding compiler `C1`.
2. Use the compiler `C20` and language `L2u` to write the compiler `C21` to understand language `L2`.
3. Now `C21` is a fully self-hosted compiler, as well as its descendants `C22`, `C23`, and `C24`.
### Where did the existing compiler `C1` come from?

There is no need to use a compiler `C1` + `L1` if you write the bootstrap compiler `C20` in machine code. This solves the chicken-and-egg problem totally for programming languages.

1. Bootstrapping initial compiler `C20`:
   1. A small and simple compiler is created manually in machine code or written in `assembly` language.
   2. [Option*] Translate the `assembly` language into machine code manually if it's not written in machine code.
   3. The initial compiler is just capable enough to understand a subset of the target language `C` it is supposed to compile.
2. Use the initial compiler `C20` to compile the compiler `C21` written in language `C` while the `C21` is also supposed to compile language `C`.
3. Now compiler `C21` a fully self-compilation.

[Strange Loops: Ken Thompson and the Self-referencing C Compiler | ScienceBlogs](https://scienceblogs.com/goodmath/2007/04/15/strange-loops-dennis-ritchie-a)

[Bootstrapping (compilers) - Wikipedia](https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29)

[Compilers: Principles, Techniques, and Tools - Wikipedia](http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools)

### Compiler's job overview

1. lexer(Lexical analysis)
   - generate tokens from source code
2. parser
   - construct abstract syntax tree(AST) from tokens
3. code generation
   - generate low-level code, such as assembly code or machine code

### Interpreter vs compiler

an **interpreter** also does `lexer` and `parser` jobs as a compiler does in step 1 and 2, but instead of generating low-level code, the **interpreter** generates the results.

### Implementations

Interpreter:

- [GitHub - rswier/c4: C in four functions](https://github.com/rswier/c4)
- [GitHub - lotabout/write-a-C-interpreter: Write a simple interpreter of C. Inspired by c4 and largely based on it.](https://github.com/lotabout/write-a-C-interpreter)

Self-hosted Compiler:

- [GitHub - DoctorWkt/acwj: A Compiler Writing Journey](https://github.com/DoctorWkt/acwj)
- [GitHub - certik/bcompile: Bootstrapping a simple compiler from nothing](https://github.com/certik/bcompile)

The basic knowledge of `lexer` and `parser` is critical and necessary for developing a programming language, 
- `flex/lex`
- `yacc/parser`

### Compiler for a subset of C language bootstrapping from Python

Recently, I am becoming interested in building a `lexer`, `parser` and `code generator` to try to create a mini language and deep insight of how `GCC` or `Clang/LLVM` do their jobs.

For educational purposes, learning in practice is my favorite approach to grasp an overview.

Let's do it!

Prerequisites:

- Python for writing the bootstrap compiler 

I use [ply](https://ply.readthedocs.io/_/downloads/en/latest/pdf/), a pure Python implementation of the `lex` and `yacc` tools to facilitate me to write the bootstrap compiler for the subset of C language.


### Compiler for a subset of C language bootstrapping from C

Prerequisites:

- An existing `GCC` for writing the bootstrap compiler

Here are some popular tutorials from [GitHub - DoctorWkt/acwj: A Compiler Writing Journey](https://github.com/DoctorWkt/acwj).

You can also refer [GitHub - lotabout/write-a-C-interpreter](https://github.com/lotabout/write-a-C-interpreter) although I prefer classifying it as **interpreter** not a complete compiler.

### Compiler bootstrapping from assembly

### Compiler bootstrapping from HEX

[GitHub - certik/bcompile: Bootstrapping a simple compiler from nothing](https://github.com/certik/bcompile)

## Resources

https://gist.github.com/mikesmullin/6259449

https://cs.lmu.edu/~ray/notes/nasmtasutorial/

https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf

http://6.s081.scripts.mit.edu/sp18/x86-64-architecture-guide.html

https://cs61.seas.harvard.edu/site/2018/Asm1/

https://web.stanford.edu/class/cs107/guide/x86-64.html

https://www.cs.virginia.edu/~evans/cs216/guides/x86.html

https://www.cs.uaf.edu/2016/fall/cs301/lecture/09_28_machinecode.html

https://p403n1x87.github.io/getting-started-with-x86-64-assembly-on-linux.html

https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html

https://nickdesaulniers.github.io/blog/2014/04/18/lets-write-some-x86-64/

https://pacman128.github.io/static/pcasm-book.pdf

https://redirect.cs.umbc.edu/portal/help/nasm/sample_64.shtml